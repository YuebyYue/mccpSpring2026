<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gaussian Splatting - Paper Structure & Interconnections</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #eee;
            padding: 10px;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            border-radius: 12px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .main-container {
            display: flex;
            gap: 15px;
            height: calc(100vh - 120px);
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Left Panel - Network Visualization */
        .network-panel {
            flex: 2;
            background: rgba(30, 30, 50, 0.9);
            border-radius: 12px;
            padding: 15px;
            overflow: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .svg-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        /* Right Panel - Details */
        .detail-panel {
            flex: 1;
            background: rgba(22, 33, 62, 0.95);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .detail-title {
            font-size: 1.2em;
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid #667eea;
            font-weight: bold;
        }

        .detail-section {
            margin-bottom: 18px;
        }

        .detail-section h4 {
            color: #a0aec0;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .detail-text {
            background: rgba(26, 26, 46, 0.8);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.85em;
            line-height: 1.6;
            color: #cbd5e0;
            border-left: 3px solid #667eea;
        }

        .detail-text em {
            color: #ffd700;
            font-style: normal;
            font-weight: 600;
        }

        .connections-list {
            list-style: none;
        }

        .connections-list li {
            background: rgba(26, 26, 46, 0.8);
            padding: 10px;
            margin: 6px 0;
            border-radius: 6px;
            font-size: 0.82em;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            border-left: 3px solid transparent;
        }

        .connections-list li:hover {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #667eea;
            transform: translateX(5px);
        }

        .arrow {
            color: #667eea;
            font-weight: bold;
        }

        /* SVG Node Styles */
        .node-circle {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node-circle:hover {
            filter: brightness(1.3) drop-shadow(0 0 8px #667eea);
        }

        .node-circle.selected {
            filter: brightness(1.5) drop-shadow(0 0 15px #ffd700);
            stroke-width: 3;
        }

        .node-text {
            pointer-events: none;
            font-size: 11px;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .edge {
            stroke: rgba(102, 126, 234, 0.4);
            stroke-width: 2;
            fill: none;
            transition: all 0.3s;
        }

        .edge.highlighted {
            stroke: #ffd700;
            stroke-width: 3;
            filter: drop-shadow(0 0 4px #ffd700);
        }

        /* Scrollbar styling */
        .detail-panel::-webkit-scrollbar {
            width: 8px;
        }

        .detail-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .detail-panel::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .detail-panel::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        .type-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-right: 8px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üé® 3D Gaussian Splatting for Real-Time Radiance Field Rendering</h1>
        <p>Interactive Paper Structure Visualization - Click nodes to explore interconnections and text excerpts</p>
    </div>

    <div class="main-container">
        <!-- Network Diagram -->
        <div class="network-panel">
            <div class="svg-container">
                <svg id="networkSvg" width="600" height="600"></svg>
            </div>
        </div>

        <!-- Detail Panel -->
        <div class="detail-panel">
            <div id="detail-title" class="detail-title">Click on a node to view details</div>
            <div id="detail-content"></div>
        </div>
    </div>

    <script>
        // Node data structure with interconnections and text excerpts
        const nodeData = {
            // Core Contributions
            intro: {
                title: "Introduction: Problem & Motivation",
                type: "Section",
                color: "#ff6b6b",
                text: `"Radiance Field methods have recently revolutionized novel-view synthesis of scenes captured with multiple photos or videos. However, achieving high visual quality still requires neural networks that are costly to train and render, while recent faster methods inevitably trade off speed for quality."

Key challenge: <em>No current method can achieve real-time display rates</em> for unbounded and complete scenes at 1080p resolution.`,
                connections: [
                    { to: "contrib1", desc: "Motivates the need for three key elements" },
                    { to: "contrib2", desc: "Drives optimization approach" },
                    { to: "contrib3", desc: "Enables the rendering solution" }
                ],
                usedBy: ["Overview of the paper"]
            },

            contrib1: {
                title: "Contribution 1: 3D Gaussians Representation",
                type: "Main Contribution",
                color: "#4ecdc4",
                text: `"The introduction of anisotropic 3D Gaussians as a high-quality, unstructured representation of radiance fields."

<em>Key innovation:</em> Starting with sparse points from SfM (Structure-from-Motion), we represent the scene with 3D Gaussians that preserve desirable properties of continuous volumetric radiance fields for scene optimization while avoiding unnecessary computation in empty space.

<em>Advantages over alternatives:</em>
‚Ä¢ More efficient than point-based solutions requiring MVS data
‚Ä¢ Differentiable volumetric representation
‚Ä¢ Can be rasterized very efficiently by projecting to 2D and applying Œ±-blending`,
                connections: [
                    { to: "optim", desc: "Input for optimization step" },
                    { to: "rendering", desc: "Enables efficient rasterization" },
                    { to: "results", desc: "Produces high-quality representations" }
                ],
                usedBy: ["Overall method", "Results"]
            },

            contrib2: {
                title: "Contribution 2: Optimization with Density Control",
                type: "Main Contribution",
                color: "#ffe66d",
                text: `"An optimization method of 3D Gaussian properties, interleaved with adaptive density control that creates high-quality representations for captured scenes."

<em>Optimization targets:</em>
‚Ä¢ 3D position
‚Ä¢ Opacity (Œ±)
‚Ä¢ Anisotropic covariance
‚Ä¢ Spherical harmonic (SH) coefficients

<em>Adaptive density control:</em> Add and occasionally remove 3D Gaussians during optimization to maintain a compact, unstructured, and precise representation (1-5 million Gaussians for all scenes tested).`,
                connections: [
                    { to: "contrib1", desc: "Optimizes Gaussian properties" },
                    { to: "rendering", desc: "Produces optimized parameters for rendering" },
                    { to: "results", desc: "Achieves SOTA quality" }
                ],
                usedBy: ["Training pipeline", "Results"]
            },

            contrib3: {
                title: "Contribution 3: Fast GPU Rendering",
                type: "Main Contribution",
                color: "#95e1d3",
                text: `"A fast, differentiable rendering approach for the GPU, which is visibility-aware, allows anisotropic splatting and fast back-propagation to achieve high-quality novel view synthesis."

<em>Technical approach:</em>
‚Ä¢ Uses fast GPU sorting algorithms
‚Ä¢ Inspired by tile-based rasterization
‚Ä¢ Performs anisotropic splatting respecting visibility ordering
‚Ä¢ Enables both accelerated training and real-time rendering at 1080p

<em>Performance:</em> Achieves ‚â•30 fps for real-time rendering with state-of-the-art quality.`,
                connections: [
                    { to: "contrib1", desc: "Rasterizes 3D Gaussians" },
                    { to: "contrib2", desc: "Uses optimized Gaussian parameters" },
                    { to: "results", desc: "Produces real-time rendering results" }
                ],
                usedBy: ["Rendering pipeline"]
            },

            // Technical Components
            optim: {
                title: "Optimization Procedure",
                type: "Technical Section",
                color: "#a8dadc",
                text: `The optimization interleaves gradient descent updates with adaptive density control steps.

<em>Training efficiency:</em>
‚Ä¢ Competitive with fastest previous methods (e.g., InstantNGP: 7 min training)
‚Ä¢ Produces equal or better quality than Mip-NeRF360 (which requires 48 hours)

<em>Key insight:</em> Starting from SfM sparse points eliminates the need for expensive Multi-View Stereo (MVS) data preprocessing.`,
                connections: [
                    { to: "contrib1", desc: "Optimizes 3D Gaussian parameters" },
                    { to: "contrib2", desc: "Implements density control" },
                    { to: "rendering", desc: "Produces parameters for real-time rendering" }
                ],
                usedBy: ["Training pipeline"]
            },

            rendering: {
                title: "Differentiable Rendering Pipeline",
                type: "Technical Section",
                color: "#f1faee",
                text: `<em>Rendering equation:</em> 
For each pixel, composite Gaussians using Œ±-blending: C = Œ£ Œ±_i ¬∑ c_i ¬∑ ‚àè(1-Œ±_j)

<em>Key features:</em>
‚Ä¢ Tile-based approach divides image into tiles
‚Ä¢ Fast visibility-aware sorting ensures correct depth ordering
‚Ä¢ Supports anisotropic splatting of 3D Gaussians to 2D
‚Ä¢ Efficient backward pass through tracking of sorted splats

<em>Performance metrics:</em>
‚Ä¢ 135 fps for MipNeRF360 scenes
‚Ä¢ 93 fps for larger datasets
‚Ä¢ Maintains image quality (PSNR ‚âà 25.2)`,
                connections: [
                    { to: "contrib3", desc: "Core of fast GPU rendering" },
                    { to: "contrib1", desc: "Processes Gaussian representations" },
                    { to: "optim", desc: "Provides gradient feedback for training" }
                ],
                usedBy: ["Real-time novel view synthesis"]
            },

            // Experimental Results
            results: {
                title: "Experimental Results & Comparison",
                type: "Results",
                color: "#06aed5",
                text: `<em>Comparative Performance:</em>

vs InstantNGP (9.2 fps):
‚Ä¢ Train: 7 min vs 7 min
‚Ä¢ PSNR: 22.1 vs 23.6 (Ours better)

vs Plenoxels (8.2 fps):
‚Ä¢ Train: 26 min vs 6 min (Ours faster)
‚Ä¢ PSNR: 21.9 vs 23.6 (Ours better)

vs Mip-NeRF360 (0.071 fps):
‚Ä¢ Train: 48 h vs 51 min (Ours 56x faster!)
‚Ä¢ PSNR: 24.3 vs 25.2 (Ours slightly better)

<em>Achievement:</em> First method to achieve real-time rendering (‚â•30 fps) with high quality for novel-view synthesis.`,
                connections: [
                    { to: "contrib1", desc: "Demonstrates effectiveness of Gaussian representation" },
                    { to: "contrib2", desc: "Shows optimization quality" },
                    { to: "contrib3", desc: "Validates real-time rendering" }
                ],
                usedBy: ["Paper conclusion"]
            },

            // Related work
            related: {
                title: "Related Work: Radiance Fields & Rendering",
                type: "Background",
                color: "#d4a5a5",
                text: `<em>Traditional approaches:</em>
‚Ä¢ Light fields (Gortler et al. 1996, Levoy & Hanrahan 1996)
‚Ä¢ Structure-from-Motion for calibration (Snavely et al. 2006)
‚Ä¢ Multi-view Stereo for dense reconstruction

<em>Recent neural methods:</em>
‚Ä¢ NeRF (continuous volumetric representation using MLPs)
‚Ä¢ Plenoxels (voxel grids, Fridovich-Keil & Yu et al. 2022)
‚Ä¢ InstantNGP (hash grids, M√ºller et al. 2022)
‚Ä¢ Mip-NeRF360 (SOTA quality but slow)

<em>Point-based methods:</em> Require MVS data or dense pre-processing

<em>Our innovation:</em> Combines benefits of explicit point representations with implicit field quality.`,
                connections: [
                    { to: "intro", desc: "Contextualizes the problem" },
                    { to: "contrib1", desc: "Contrasts with related representations" },
                    { to: "contrib3", desc: "Inspired by prior tile-based rasterization work" }
                ],
                usedBy: ["Introduction", "Motivation"]
            }
        };

        // Create network graph using SVG
        function createNetwork() {
            const svg = document.getElementById('networkSvg');

            // Define positions for nodes in a circular/network layout
            const positions = {
                intro: { x: 300, y: 150 },
                contrib1: { x: 150, y: 300 },
                contrib2: { x: 300, y: 300 },
                contrib3: { x: 450, y: 300 },
                optim: { x: 150, y: 450 },
                rendering: { x: 450, y: 450 },
                results: { x: 300, y: 550 },
                related: { x: 100, y: 100 }
            };

            // Draw edges first (so they appear behind nodes)
            const edges = [];
            Object.keys(nodeData).forEach(nodeId => {
                const node = nodeData[nodeId];
                if (node.connections) {
                    node.connections.forEach(conn => {
                        edges.push({ from: nodeId, to: conn.to });
                    });
                }
            });

            // Remove duplicate edges
            const uniqueEdges = [];
            edges.forEach(edge => {
                if (!uniqueEdges.find(e =>
                    (e.from === edge.from && e.to === edge.to) ||
                    (e.from === edge.to && e.to === edge.from)
                )) {
                    uniqueEdges.push(edge);
                }
            });

            // Draw edges
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#667eea" />
                </marker>
                <marker id="arrowhead-gold" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#ffd700" />
                </marker>
            `;
            svg.appendChild(defs);

            uniqueEdges.forEach((edge, idx) => {
                const from = positions[edge.from];
                const to = positions[edge.to];
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', from.x);
                line.setAttribute('y1', from.y);
                line.setAttribute('x2', to.x);
                line.setAttribute('y2', to.y);
                line.setAttribute('class', 'edge');
                line.setAttribute('id', `edge-${edge.from}-${edge.to}`);
                line.setAttribute('marker-end', 'url(#arrowhead)');
                svg.appendChild(line);
            });

            // Draw nodes
            Object.keys(nodeData).forEach(nodeId => {
                const node = nodeData[nodeId];
                const pos = positions[nodeId];

                // Node group
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('data-id', nodeId);
                g.setAttribute('cursor', 'pointer');

                // Circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', 35);
                circle.setAttribute('fill', node.color);
                circle.setAttribute('class', 'node-circle');
                circle.setAttribute('opacity', '0.8');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');

                // Text label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', pos.y);
                text.setAttribute('class', 'node-text');

                // Shorten label for readability
                const label = nodeId.replace(/_/g, ' ').toUpperCase();
                const shortLabel = label.length > 10 ? label.substring(0, 10) + '.' : label;
                text.textContent = shortLabel;

                g.appendChild(circle);
                g.appendChild(text);
                g.addEventListener('click', () => selectNode(nodeId));

                svg.appendChild(g);
            });
        }

        function selectNode(id) {
            // Clear previous selection
            document.querySelectorAll('.node-circle').forEach(c => c.classList.remove('selected'));
            document.querySelectorAll('.edge').forEach(e => {
                e.classList.remove('highlighted');
                e.setAttribute('marker-end', 'url(#arrowhead)');
            });

            // Highlight selected node
            const node = document.querySelector(`[data-id="${id}"] .node-circle`);
            if (node) node.classList.add('selected');

            // Highlight connected edges
            const data = nodeData[id];
            if (data && data.connections) {
                data.connections.forEach(conn => {
                    const edge = document.getElementById(`edge-${id}-${conn.to}`);
                    if (edge) {
                        edge.classList.add('highlighted');
                        edge.setAttribute('marker-end', 'url(#arrowhead-gold)');
                    }
                });
            }

            // Update detail panel
            updateDetailPanel(id);
        }

        function updateDetailPanel(id) {
            const data = nodeData[id];
            if (!data) return;

            const titleEl = document.getElementById('detail-title');
            const contentEl = document.getElementById('detail-content');

            titleEl.innerHTML = `<span class="type-badge">${data.type}</span>${data.title}`;

            let html = `
                <div class="detail-section">
                    <h4>üìù Content</h4>
                    <div class="detail-text">${data.text}</div>
                </div>
            `;

            if (data.connections && data.connections.length > 0) {
                html += `
                    <div class="detail-section">
                        <h4>üîó Connections To</h4>
                        <ul class="connections-list">
                            ${data.connections.map(c => `
                                <li onclick="selectNode('${c.to}')" title="Click to explore">
                                    <span class="arrow">‚Üí</span>
                                    <span><strong>${nodeData[c.to]?.title.split(':')[0] || c.to}</strong>: ${c.desc}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }

            if (data.usedBy && data.usedBy.length > 0) {
                html += `
                    <div class="detail-section">
                        <h4>üìå Used By</h4>
                        <div class="detail-text">${data.usedBy.join('<br>')}</div>
                    </div>
                `;
            }

            contentEl.innerHTML = html;
        }

        // Initialize
        createNetwork();
        selectNode('intro');  // Start with introduction
    </script>
</body>

</html>